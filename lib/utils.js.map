{"version":3,"sources":["../src/utils.js"],"names":["find","deepCopy","forEachValue","isObject","isPromise","assert","list","f","filter","obj","cache","hit","c","original","copy","Array","isArray","push","Object","keys","forEach","key","fn","val","then","condition","msg","Error"],"mappings":";;;;;;;;QAQgBA,I,GAAAA,I;QAaAC,Q,GAAAA,Q;QA8BAC,Y,GAAAA,Y;QAIAC,Q,GAAAA,Q;QAIAC,S,GAAAA,S;QAIAC,M,GAAAA,M;AA/DhB;;;;;;;;AAQO,SAASL,IAAT,CAAcM,IAAd,EAAoBC,CAApB,EAAuB;AAC5B,SAAOD,KAAKE,MAAL,CAAYD,CAAZ,EAAe,CAAf,CAAP;AACD;;AAED;;;;;;;;;AASO,SAASN,QAAT,CAAkBQ,GAAlB,EAAmC;AAAA,MAAZC,KAAY,uEAAJ,EAAI;;AACxC;AACA,MAAID,QAAQ,IAAR,IAAgB,QAAOA,GAAP,yCAAOA,GAAP,OAAe,QAAnC,EAA6C;AAC3C,WAAOA,GAAP;AACD;;AAED;AACA,MAAME,MAAMX,KAAKU,KAAL,EAAY;AAAA,WAAKE,EAAEC,QAAF,KAAeJ,GAApB;AAAA,GAAZ,CAAZ;AACA,MAAIE,GAAJ,EAAS;AACP,WAAOA,IAAIG,IAAX;AACD;;AAED,MAAMA,OAAOC,MAAMC,OAAN,CAAcP,GAAd,IAAqB,EAArB,GAA0B,EAAvC;AACA;AACA;AACAC,QAAMO,IAAN,CAAW;AACTJ,cAAUJ,GADD;AAETK;AAFS,GAAX;;AAKAI,SAAOC,IAAP,CAAYV,GAAZ,EAAiBW,OAAjB,CAAyB,eAAO;AAC9BN,SAAKO,GAAL,IAAYpB,SAASQ,IAAIY,GAAJ,CAAT,EAAmBX,KAAnB,CAAZ;AACD,GAFD;;AAIA,SAAOI,IAAP;AACD;;AAED;;;AAGO,SAASZ,YAAT,CAAsBO,GAAtB,EAA2Ba,EAA3B,EAA+B;AACpCJ,SAAOC,IAAP,CAAYV,GAAZ,EAAiBW,OAAjB,CAAyB;AAAA,WAAOE,GAAGb,IAAIY,GAAJ,CAAH,EAAaA,GAAb,CAAP;AAAA,GAAzB;AACD;;AAEM,SAASlB,QAAT,CAAkBM,GAAlB,EAAuB;AAC5B,SAAOA,QAAQ,IAAR,IAAgB,QAAOA,GAAP,yCAAOA,GAAP,OAAe,QAAtC;AACD;;AAEM,SAASL,SAAT,CAAmBmB,GAAnB,EAAwB;AAC7B,SAAOA,OAAO,OAAOA,IAAIC,IAAX,KAAoB,UAAlC;AACD;;AAEM,SAASnB,MAAT,CAAgBoB,SAAhB,EAA2BC,GAA3B,EAAgC;AACrC,MAAI,CAACD,SAAL,EAAgB,MAAM,IAAIE,KAAJ,aAAoBD,GAApB,CAAN;AACjB","file":"utils.js","sourcesContent":["/**\r\n * Get the first item that pass the test\r\n * by second argument function\r\n *\r\n * @param {Array} list\r\n * @param {Function} f\r\n * @return {*}\r\n */\r\nexport function find(list, f) {\r\n  return list.filter(f)[0]\r\n}\r\n\r\n/**\r\n * Deep copy the given object considering circular structure.\r\n * This function caches all nested objects and its copies.\r\n * If it detects circular structure, use cached copy to avoid infinite loop.\r\n *\r\n * @param {*} obj\r\n * @param {Array<Object>} cache\r\n * @return {*}\r\n */\r\nexport function deepCopy(obj, cache = []) {\r\n  // just return if obj is immutable value\r\n  if (obj === null || typeof obj !== 'object') {\r\n    return obj\r\n  }\r\n\r\n  // if obj is hit, it is in circular structure\r\n  const hit = find(cache, c => c.original === obj)\r\n  if (hit) {\r\n    return hit.copy\r\n  }\r\n\r\n  const copy = Array.isArray(obj) ? [] : {}\r\n  // put the copy into cache at first\r\n  // because we want to refer it in recursive deepCopy\r\n  cache.push({\r\n    original: obj,\r\n    copy\r\n  })\r\n\r\n  Object.keys(obj).forEach(key => {\r\n    copy[key] = deepCopy(obj[key], cache)\r\n  })\r\n\r\n  return copy\r\n}\r\n\r\n/**\r\n * forEach for object\r\n */\r\nexport function forEachValue(obj, fn) {\r\n  Object.keys(obj).forEach(key => fn(obj[key], key))\r\n}\r\n\r\nexport function isObject(obj) {\r\n  return obj !== null && typeof obj === 'object'\r\n}\r\n\r\nexport function isPromise(val) {\r\n  return val && typeof val.then === 'function'\r\n}\r\n\r\nexport function assert(condition, msg) {\r\n  if (!condition) throw new Error(`[vuex] ${msg}`)\r\n}\r\n"]}